extends Node
class 等级经验系统:
	# 加密存储核心数据（用浮点数加密兼容整数）
	
	var _加密累计经验 = 引擎.加解密.浮点数加密(0.0)  # 累计总经验（加密）
	var _加密当前等级 = 引擎.加解密.浮点数加密(1.0)  # 当前等级（加密）
	
	# 外部配置参数（通过方法注入）
	var _等级上限: int = 99  # 等级上限（整数）
	var _经验计算函数: Callable = Callable()  # 直接存储经验计算函数
	var _升级奖励回调: Callable = Callable()  # 升级奖励回调
	
	# ==============================================
	# 初始化与配置
	# ==============================================
	func _init(等级上限: int = 99) -> void:
		_等级上限 = 等级上限
	
	
	func 配置经验公式(经验计算函数: Callable) -> void:
		if 经验计算函数.is_valid():
			_经验计算函数 = 经验计算函数  # 用新变量存储函数
		else:
			引擎.调试.警告("请传入有效的经验计算函数")
	# 配置升级奖励回调
	func 配置升级奖励(回调: Callable) -> void:
		_升级奖励回调 = 回调
	
	# ==============================================
	# 核心数据操作（浮点数加密/解密，解密后取整）
	# ==============================================
	# 获取当前累计经验（解密后转为整数）
	func 获取累计经验() -> int:
		return int(round(引擎.加解密.浮点数解密(_加密累计经验)))
	
	# 设置总经验（转为浮点数加密存储）
	func 设置累计经验(值: int,触发升级奖励:bool=false) -> void:
		var 有效经验 = max(0, 值)  # 经验不能为负
		_加密累计经验 = 引擎.加解密.浮点数加密(float(有效经验))
		_同步等级(触发升级奖励)  # 同步等级
	
	# 增加经验（整数增加值）
	func 增加经验(增加值: int) -> void:
		if 增加值 <= 0:
			return
		设置累计经验(获取累计经验() + 增加值,true)
	func 减少经验(减少值: int, 允许降级: bool = false) -> void:
		if 减少值 <= 0:
			return  # 减少值必须为正数
		
		var 当前总经验 = 获取累计经验()
		var 当前等级内经验 = 获取当前经验()  # 当前等级的已有经验（不包含上一级累计）
		
		# 计算最大可扣除的经验
		var 最大可扣经验 = 当前总经验 if 允许降级 else 当前等级内经验
		var 实际扣除 = min(减少值, 最大可扣经验)  # 实际扣除不超过最大可扣量
		var 新经验 = 当前总经验 - 实际扣除
		
		# 设置新经验，触发等级同步（允许降级时才可能触发降级逻辑）
		设置累计经验(新经验, 允许降级)
	# 获取当前等级（解密后转为整数）
	func 获取当前等级() -> int:
		return int(round(引擎.加解密.浮点数解密(_加密当前等级)))
	
	# ==============================================
	# 等级计算与同步
	# ==============================================
	# 定义内部函数：计算“升到目标等级所需的累计总经验”
		# （累加从1级到目标等级-1级的单级经验）
	func _计算累计经验(目标等级: int) -> int:
		if 目标等级 <= 1:
			return 0  # 1级无需经验
		# 直接返回“升到目标等级需要的总累计经验”（即经验公式定义的值）
		return _经验计算函数.call(目标等级-1)
	func _同步等级(触发升级奖励: bool = true) -> void:
		if _经验计算函数.is_null():
			return
		var 旧等级 = 获取当前等级()
		var 当前总经验 = 获取累计经验()
		var 新等级 = 旧等级
		var 等级提升 = false  # 标记是否发生过升级（用于降级逻辑判断）
		# --------------------------
		# 升级逻辑：从当前等级往上判断
		# --------------------------
		while 新等级 < _等级上限:
			var 下一级 = 新等级 + 1
			var 下一级所需累计 = _计算累计经验(下一级)  # 升到下一级需要的总累计经验
			
			if 当前总经验 >= 下一级所需累计:
				# 满足升级条件，更新等级
				新等级 = 下一级
				等级提升 = true  # 标记发生了升级
				# 加密存储新等级
				_加密当前等级 = 引擎.加解密.浮点数加密(float(新等级))
				
				# 触发奖励（如果允许）
				if 触发升级奖励:
					
					if _升级奖励回调:
						_升级奖励回调.call(新等级, 新等级 - 1)  # 执行奖励回调
			else:
				# 经验不足，停止升级判断
				break
		
		# --------------------------
		# 降级逻辑：如果未升级，检查是否需要降级
		# --------------------------
		if not 等级提升:  # 只有未发生升级时，才可能需要降级
			while 新等级 > 1:  # 最低等级为1
				var 当前级所需累计 = _计算累计经验(新等级)  # 当前等级的累计经验要求
				
				if 当前总经验 < 当前级所需累计:
					# 经验不足当前等级，降级
					新等级 -= 1
					# 加密存储新等级
					_加密当前等级 = 引擎.加解密.浮点数加密(float(新等级))
					
					# 触发降级奖励（如果允许）
					if 触发升级奖励:
						
						if _升级奖励回调:
							_升级奖励回调.call(新等级, 新等级 + 1)  # 执行降级回调（如果需要）
				else:
					# 经验满足当前等级，停止降级判断
					break
		
	# ==============================================
	# 辅助工具方法
	# ==============================================
	func _获取当前等级的累计上限() -> int: #当前等级上限经验
		if _经验计算函数.is_null():
			return -1
		return _经验计算函数.call(获取当前等级())
	func _获取上一级的累计上限() -> int:#上一级上限经验
		if _经验计算函数.is_null():
			return -1
		return _经验计算函数.call(获取当前等级()-1)
	func 获取当前经验()->int:#计算当前等级经验量
		if _经验计算函数.is_null():
			return -1
		return 获取累计经验()-_获取上一级的累计上限()
	func 获取当前经验上限()->int:#计算当前等级总经验量
		if _经验计算函数.is_null():
			return -1
		return  _获取当前等级的累计上限()-_获取上一级的累计上限()
	
	# 重置
	func 重置() -> void:
		_加密累计经验 = 引擎.加解密.浮点数加密(0.0)
		_加密当前等级 = 引擎.加解密.浮点数加密(1.0)
